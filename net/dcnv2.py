import torch
import torch.nn as nn

class SelfDCNv2(nn.Module):
    def __init__(self, nf_in, nf_out, ks=3, stride=1, padding=1, ngroups=0, bias=False):
        super().__init__()
        
        self.nf_in = nf_in
        self.nf_out = nf_out
        self.ks = ks
        self.stride = stride
        self.padding = padding
        self.ngroups = ngroups if ngroups != 0 else nf_in  # group=in_nc, i.e., each map use individual offset and mask
        self.bias = bias

        # regression head
        # why in_nc*3*size_dk?
        #   in_nc: each map use individual offset and mask
        #   2*size_dk: 2 coordinates for each point
        #   1*size_dk: 1 confidence (attention) score for each point
        self.ks_square = self.ks ** 2
        self.conv_offset_mask = nn.Conv2d(
            in_channels=self.nf_in,
            out_channels=self.nf_in*3*self.ks_square,
            kernel_size=self.ks,
            padding=self.padding,
            bias=True,  # uncertain
        )

        from .ops.dcn.deform_conv import ModulatedDeformConv
        self.conv = ModulatedDeformConv(
            in_channels=self.nf_in,
            out_channels=self.nf_out,
            kernel_size=self.ks,
            stride=self.stride,
            padding=self.padding,
            deformable_groups=self.ngroups,  
            bias=self.bias,
        )

    def forward(self, inp_t):
        off_msk = self.conv_offset_mask(inp_t)
        off = off_msk[:, :self.nf_in*2*self.ks_square, ...]
        msk = torch.sigmoid(
            off_msk[:, self.nf_in*2*self.ks_square:, ...]
        )

        out_t = self.conv(inp_t, off, msk)
        return out_t

class DCNv2(nn.Module):
    """
    The offsets and the importance mask are generated by a set of feature maps, not inp_t itself.
    """
    def __init__(self, nf_in_msk, nf_in, nf_out, ks=3, stride=1, padding=1, ngroups=0, bias=False):
        super().__init__()
        
        self.nf_in_msk = nf_in_msk
        self.nf_in = nf_in
        self.nf_out = nf_out
        self.ks = ks
        self.stride = stride
        self.padding = padding
        self.ngroups = ngroups if ngroups != 0 else nf_in  # group=in_nc, i.e., each map use individual offset and mask
        self.bias = bias

        # regression head
        # why in_nc*3*size_dk?
        #   in_nc: each map use individual offset and mask
        #   2*size_dk: 2 coordinates for each point
        #   1*size_dk: 1 confidence (attention) score for each point
        self.ks_square = self.ks ** 2
        self.conv_offset_mask = nn.Conv2d(
            in_channels=self.nf_in_msk,
            out_channels=self.nf_in*3*self.ks_square,
            kernel_size=self.ks,
            padding=self.padding,
            bias=True,  # uncertain
        )

        from .ops.dcn.deform_conv import ModulatedDeformConv
        self.conv = ModulatedDeformConv(
            in_channels=self.nf_in,
            out_channels=self.nf_out,
            kernel_size=self.ks,
            stride=self.stride,
            padding=self.padding,
            deformable_groups=self.ngroups,  
            bias=self.bias,
        )

    def forward(self, inp_msk, inp_t):
        off_msk = self.conv_offset_mask(inp_msk)
        off = off_msk[:, :self.nf_in*2*self.ks_square, ...]
        msk = torch.sigmoid(
            off_msk[:, self.nf_in*2*self.ks_square:, ...]
        )

        out_t = self.conv(inp_t, off, msk)
        return out_t